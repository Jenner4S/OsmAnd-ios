//
//  OARouteProvider.m
//  OsmAnd
//
//  Created by Alexey Kulish on 27/06/2017.
//  Copyright Â© 2017 OsmAnd. All rights reserved.
//

#import "OARouteProvider.h"
#import "OAGPXDocument.h"
#import "OAAppSettings.h"
#import "OAGPXDocumentPrimitives.h"
#import "OARouteDirectionInfo.h"
#import "OsmAndApp.h"

#define OSMAND_ROUTER @"OsmAndRouter"

@interface OARouteProvider()

+ (NSArray<OARouteDirectionInfo *> *) parseOsmAndGPXRoute:(NSArray<CLLocation *> *)res gpxFile:(OAGPXDocument *)gpxFile osmandRouter:(BOOL)osmandRouter leftSide:(BOOL)leftSide defSpeed:(float)defSpeed;

@end

@interface OARouteService()

@property (nonatomic) EOARouteService service;

@end

@implementation OARouteService

+ (instancetype)withService:(EOARouteService)service
{
    OARouteService *obj = [[OARouteService alloc] init];
    if (obj)
    {
        obj.service = service;
    }
    return obj;
}

+ (NSString *)getName:(EOARouteService)service
{
    switch (service)
    {
        case OSMAND:
            return @"OsmAnd (offline)";
        case YOURS:
            return @"YOURS";
        case OSRM:
            return @"OSRM (only car)";
        case BROUTER:
            return @"BRouter (offline)";
        case STRAIGHT:
            return @"Straight line";
        default:
            return @"";
    }
}

+ (BOOL) isOnline:(EOARouteService)service
{
    return service != OSMAND && service != BROUTER;
}

+ (BOOL) isAvailable:(EOARouteService)service
{
    if (service == BROUTER) {
        return NO; //ctx.getBRouterService() != null;
    }
    return YES;
}

+ (NSArray<OARouteService *> *) getAvailableRouters
{
    NSMutableArray<OARouteService *> *res = [NSMutableArray array];
    if ([OARouteService isAvailable:OSMAND])
        [res addObject:[OARouteService withService:OSMAND]];
    if ([OARouteService isAvailable:YOURS])
        [res addObject:[OARouteService withService:YOURS]];
    if ([OARouteService isAvailable:OSRM])
        [res addObject:[OARouteService withService:OSRM]];
    if ([OARouteService isAvailable:BROUTER])
        [res addObject:[OARouteService withService:BROUTER]];
    if ([OARouteService isAvailable:STRAIGHT])
        [res addObject:[OARouteService withService:STRAIGHT]];
    return [NSArray arrayWithArray:res];
}

@end

@interface OAGPXRouteParams()

@end

@implementation OAGPXRouteParams

- (instancetype)init
{
    self = [super init];
    if (self)
    {
        _addMissingTurns = YES;
    }
    return self;
}

- (OAGPXRouteParams *) prepareGPXFile:(OAGPXRouteParamsBuilder *)builder
{
    OAGPXDocument *file = builder.file;
    BOOL reverse = builder.reverse;
    self.passWholeRoute = builder.passWholeRoute;
    self.calculateOsmAndRouteParts = builder.calculateOsmAndRouteParts;
    self.useIntermediatePointsRTE = builder.useIntermediatePointsRTE;
    builder.calculateOsmAndRoute = NO; // Disabled temporary builder.calculateOsmAndRoute;
    if (file.locationMarks.count > 0)
    {
        self.wpt = [NSArray arrayWithArray:file.locationMarks];
    }
    if ([file isCloudmadeRouteFile] || [OSMAND_ROUTER isEqualToString:file.creator])
    {
        NSMutableArray<CLLocation *> *points = [NSMutableArray arrayWithArray:self.points];
        self.directions = [OARouteProvider parseOsmAndGPXRoute:points gpxFile:file osmandRouter:[OSMAND_ROUTER isEqualToString:file.creator] leftSide:builder.leftSide defSpeed:10];
        self.points = [NSArray arrayWithArray:points];
        if ([OSMAND_ROUTER isEqualToString:file.creator])
        {
            // For files generated by OSMAND_ROUTER use directions contained unaltered
            self.addMissingTurns = NO;
        }
        if (reverse)
        {
            // clear directions all turns should be recalculated
            self.directions = nil;
            self.points = [[self.points reverseObjectEnumerator] allObjects];
            self.addMissingTurns = YES;
        }
    }
    else
    {
        NSMutableArray<CLLocation *> *points = [NSMutableArray arrayWithArray:self.points];
        // first of all check tracks
        if (!self.useIntermediatePointsRTE)
        {
            for (OAGpxTrk *tr in file.tracks)
            {
                for (OAGpxTrkSeg *tkSeg in tr.segments)
                {
                    for (OAGpxTrkPt *pt in tkSeg.points)
                    {
                        CLLocation *loc = [[CLLocation alloc] initWithCoordinate:CLLocationCoordinate2DMake(pt.position.latitude, pt.position.longitude) altitude:pt.elevation horizontalAccuracy:pt.horizontalDilutionOfPrecision verticalAccuracy:pt.verticalDilutionOfPrecision course:0 speed:pt.speed timestamp:[NSDate dateWithTimeIntervalSince1970:pt.time]];

                        [points addObject:loc];
                    }
                }
            }
        }
        if (points.count == 0)
        {
            for (OAGpxRte *rte in file.routes)
            {
                for (OAGpxRtePt *pt in rte.points)
                {
                    CLLocation *loc = [[CLLocation alloc] initWithCoordinate:CLLocationCoordinate2DMake(pt.position.latitude, pt.position.longitude) altitude:pt.elevation horizontalAccuracy:pt.horizontalDilutionOfPrecision verticalAccuracy:pt.verticalDilutionOfPrecision course:0 speed:pt.speed timestamp:[NSDate dateWithTimeIntervalSince1970:pt.time]];
                    
                    [points addObject:loc];
                }
            }
        }
        if (reverse)
        {
            self.points = [[points reverseObjectEnumerator] allObjects];
        }
        else
        {
            self.points = [NSArray arrayWithArray:points];
        }
    }
    return self;
}

@end

@interface OAGPXRouteParamsBuilder()

@end

@implementation OAGPXRouteParamsBuilder

- (instancetype)initWithDoc:(OAGPXDocument *)document
{
    self = [super init];
    if (self) {
        _file = document;
        _leftSide = [OADrivingRegion isLeftHandDriving:[OAAppSettings sharedManager].settingDrivingRegion];
    }
    return self;
}

@end


@implementation OARouteProvider

- (instancetype)init
{
    self = [super init];
    if (self) {
    }
    return self;
}

+ (NSString *) getExtensionValue:(OAGpxExtensions *)exts key:(NSString *)key
{
    for (OAGpxExtension *e in exts.extensions) {
        if ([e.name isEqualToString:key]) {
            return e.value;
        }
    }
    return nil;
}

+ (NSArray<OARouteDirectionInfo *> *) parseOsmAndGPXRoute:(NSMutableArray<CLLocation *> *)res gpxFile:(OAGPXDocument *)gpxFile osmandRouter:(BOOL)osmandRouter leftSide:(BOOL)leftSide defSpeed:(float)defSpeed
{
    NSMutableArray<OARouteDirectionInfo *> *directions = nil;
    if (!osmandRouter)
    {
        for (OAGpxWpt *pt in gpxFile.locationMarks)
        {
            CLLocation *loc = [[CLLocation alloc] initWithCoordinate:CLLocationCoordinate2DMake(pt.position.latitude, pt.position.longitude) altitude:pt.elevation horizontalAccuracy:pt.horizontalDilutionOfPrecision verticalAccuracy:pt.verticalDilutionOfPrecision course:0 speed:pt.speed timestamp:[NSDate dateWithTimeIntervalSince1970:pt.time]];
            
            [res addObject:loc];
        }
    }
    else
    {
        for (OAGpxTrk *tr in gpxFile.tracks)
        {
            for (OAGpxTrkSeg *ts in tr.segments)
            {
                for (OAGpxTrkPt *pt in ts.points)
                {
                    CLLocation *loc = [[CLLocation alloc] initWithCoordinate:CLLocationCoordinate2DMake(pt.position.latitude, pt.position.longitude) altitude:pt.elevation horizontalAccuracy:pt.horizontalDilutionOfPrecision verticalAccuracy:pt.verticalDilutionOfPrecision course:0 speed:pt.speed timestamp:[NSDate dateWithTimeIntervalSince1970:pt.time]];
                    
                    [res addObject:loc];
                }
            }
        }
    }
    NSMutableArray<NSNumber *> *distanceToEnd  = [NSMutableArray arrayWithCapacity:res.count];
    for (int i = (int)res.count - 2; i >= 0; i--)
    {
        distanceToEnd[i] = @(distanceToEnd[i + 1].floatValue + [res[i] distanceFromLocation:res[i + 1]]);
    }
    
    OARoute *route = nil;
    if (gpxFile.routes.count > 0)
    {
        route = gpxFile.routes[0];
    }
    OALocationServices *locationServices = [OsmAndApp instance].locationServices;
    OARouteDirectionInfo *previous = nil;
    if (route && route.points.count > 0)
    {
        directions = [NSMutableArray array];
        for (int i = 0; i < route.points.count; i++)
        {
            OAGpxRtePt *item = route.points[i];
            try
            {
                OAGpxExtensions *exts = (OAGpxExtensions *)item.extraData;
                
                NSString *stime = [OARouteProvider getExtensionValue:exts key:@"time"];
                int time  = 0;
                if (stime)
                    time = [stime intValue];
                
                int offset = [[OARouteProvider getExtensionValue:exts key:@"offset"] intValue];
                if (directions.count > 0)
                {
                    OARouteDirectionInfo *last = directions[directions.count - 1];
                    // update speed using time and idstance
                    last.averageSpeed = ((distanceToEnd[last.routePointOffset].floatValue - distanceToEnd[offset].floatValue) / last.averageSpeed);
                    last.distance = (int) round(distanceToEnd[last.routePointOffset].floatValue - distanceToEnd[offset].floatValue);
                } 
                // save time as a speed because we don't know distance of the route segment
                float avgSpeed = time;
                if (i == route.points.count - 1 && time > 0)
                    avgSpeed = distanceToEnd[offset].floatValue / time;
                
                NSString *stype = [OARouteProvider getExtensionValue:exts key:@"turn"];
                std::shared_ptr<TurnType> turnType = nullptr;
                if (stype)
                    turnType = std::make_shared<TurnType>(TurnType::fromString([[stype uppercaseString] UTF8String], leftSide));
                else
                    turnType = TurnType::ptrStraight();
                
                NSString *sturn = [OARouteProvider getExtensionValue:exts key:@"turn-angle"];
                if (sturn)
                    turnType->setTurnAngle([sturn floatValue]);
                
                OARouteDirectionInfo *dirInfo = [[OARouteDirectionInfo alloc] initWithAverageSpeed:avgSpeed turnType:turnType];
                [dirInfo setDescriptionRoute:item.desc];
                dirInfo.routePointOffset = offset;
                
                // Issue #2894
                NSString *sref = [OARouteProvider getExtensionValue:exts key:@"ref"];
                if (sref && ![@"null" isEqualToString:sref])
                    dirInfo.ref = sref;

                NSString *sstreetname = [OARouteProvider getExtensionValue:exts key:@"street-name"];
                if (sstreetname && ![@"null" isEqualToString:sstreetname])
                    dirInfo.streetName = sstreetname;
                
                NSString *sdest = [OARouteProvider getExtensionValue:exts key:@"dest"];
                if (sdest && ![@"null" isEqualToString:sdest])
                    dirInfo.destinationName = sdest;
                
                if (previous && TurnType::C != previous.turnType->getValue() && !osmandRouter)
                {
                    // calculate angle
                    if (previous.routePointOffset > 0)
                    {
                        CLLocationCoordinate2D coord1 = res[previous.routePointOffset - 1].coordinate;
                        CLLocationCoordinate2D coord2 = res[previous.routePointOffset].coordinate;
                        double distance, bearing;
                        [locationServices computeDistanceAndBearing:coord1.latitude lon1:coord1.longitude lat2:coord2.latitude lon2:coord2.longitude distance:&distance initialBearing:&bearing];
                        
                        float paz = bearing;
                        float caz;
                        if (previous.turnType->isRoundAbout() && dirInfo.routePointOffset < res.count - 1)
                        {
                            bearing = 0;
                            coord1 = res[previous.routePointOffset].coordinate;
                            coord2 = res[previous.routePointOffset + 1].coordinate;
                            [locationServices computeDistanceAndBearing:coord1.latitude lon1:coord1.longitude lat2:coord2.latitude lon2:coord2.longitude distance:&distance initialBearing:&bearing];

                            caz = bearing;
                        }
                        else
                        {
                            bearing = 0;
                            coord1 = res[previous.routePointOffset - 1].coordinate;
                            coord2 = res[previous.routePointOffset].coordinate;
                            [locationServices computeDistanceAndBearing:coord1.latitude lon1:coord1.longitude lat2:coord2.latitude lon2:coord2.longitude distance:&distance initialBearing:&bearing];
                            
                            caz = bearing;
                        }
                        float angle = caz - paz;
                        if (angle < 0)
                            angle += 360;
                        else if (angle > 360)
                            angle -= 360;
                        
                        // that magic number helps to fix some errors for turn
                        angle += 75;
                        
                        if (previous.turnType->getTurnAngle() < 0.5f) {
                            previous.turnType->setTurnAngle(angle);
                        }
                    }
                }
                
                [directions addObject:dirInfo];
                
                previous = dirInfo;
            } catch (NSException *e) {
            }
        }
    }
    
    if (previous && TurnType::C != previous.turnType->getValue())
    {
        // calculate angle
        if (previous.routePointOffset > 0 && previous.routePointOffset < res.count - 1)
        {
            CLLocationCoordinate2D coord1 = res[previous.routePointOffset - 1].coordinate;
            CLLocationCoordinate2D coord2 = res[previous.routePointOffset].coordinate;
            double distance, bearing;
            [locationServices computeDistanceAndBearing:coord1.latitude lon1:coord1.longitude lat2:coord2.latitude lon2:coord2.longitude distance:&distance initialBearing:&bearing];

            float paz = bearing;

            coord1 = res[previous.routePointOffset].coordinate;
            coord2 = res[res.count - 1].coordinate;
            bearing = 0;
            [locationServices computeDistanceAndBearing:coord1.latitude lon1:coord1.longitude lat2:coord2.latitude lon2:coord2.longitude distance:&distance initialBearing:&bearing];

            float caz = bearing;
            
            float angle = caz - paz;
            if (angle < 0)
                angle += 360;
            
            if (previous.turnType->getTurnAngle() < 0.5f)
                previous.turnType->setTurnAngle(angle);
        }
    }
    return directions;
}

@end
